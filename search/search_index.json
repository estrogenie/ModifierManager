{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ModifierManager","text":"<p>A flexible, type-safe stat modifier system for Roblox games.</p> <p>Manage buffs, debuffs, equipment bonuses, and any numeric stat modifications with automatic expiration, stacking rules, and client synchronization.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Three Manager Types - EntityManager for NPCs/objects, PlayerManager with client sync, ClientStatReader for clients</li> <li>Modifier Types - Additive, Multiplicative, and Override</li> <li>Stacking Rules - Stack, Replace, Highest, Refresh</li> <li>Automatic Expiration - Time-based modifier removal with efficient scheduling</li> <li>Change Notifications - Subscribe to stat changes with signals</li> <li>Tag System - Organize and query modifiers by tags</li> <li>Type-Safe - Full Luau strict mode with exported types</li> <li>Zero Dependencies - Signal and Trove embedded internally</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#wally","title":"Wally","text":"<pre><code>[dependencies]\nModifierManager = \"estrogenie/modifier-manager@1.0.0\"\n</code></pre>"},{"location":"#manual","title":"Manual","text":"<ol> <li>Download the <code>ModifierManager</code> folder from the repository</li> <li>Place it in <code>ReplicatedStorage</code> (or your preferred location)</li> <li>Require it in your scripts</li> </ol> <pre><code>local ModifierManager = require(ReplicatedStorage.ModifierManager)\n</code></pre>"},{"location":"#choosing-a-manager","title":"Choosing a Manager","text":"Manager Key Type Environment Use Case <code>EntityManager</code> <code>string</code> Server NPCs, objects, world entities <code>PlayerManager</code> <code>Player</code> Server Player stats with automatic client sync <code>ClientStatReader</code> - Client Read-only access to synced player stats <p>Warning</p> <p><code>EntityManager</code> and <code>PlayerManager</code> can only be created on the server. Use <code>ClientStatReader</code> on the client for reading synced stats.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>local ModifierManager = require(ReplicatedStorage.ModifierManager)\n\nlocal entityStats = ModifierManager.EntityManager.new()\n\nentityStats:SetBase(\"enemy_1\", \"Combat.Health\", 100)\n\nentityStats:AddModifier({\n    entity = \"enemy_1\",\n    path = \"Combat.Health\",\n    value = 50,\n    type = \"Additive\",\n    source = \"HealthPotion\",\n    duration = 30,\n})\n\n-- Returns 150\nlocal health = entityStats:Get(\"enemy_1\", \"Combat.Health\")\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Tutorial - Full walkthrough: server setup, client sync, modifiers, stacking rules, and removal</li> <li>Best Practices - Recommended patterns: data-driven config, sync setup, and a movement system example</li> <li>API Reference - Complete method documentation and type definitions</li> <li>Changelog - Version history</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#module","title":"Module","text":"<pre><code>local ModifierManager = require(ReplicatedStorage.ModifierManager)\n</code></pre>"},{"location":"api/#exports","title":"Exports","text":"Export Description <code>ModifierManager.EntityManager</code> Server-side manager for string-keyed entities <code>ModifierManager.PlayerManager</code> Server-side manager for Player-keyed stats with sync <code>ModifierManager.ClientStatReader</code> Client-side read-only stat reader"},{"location":"api/#entitymanager","title":"EntityManager","text":"<p>Server-side manager for string-keyed entities (NPCs, objects, etc.).</p> <p>Warning</p> <p>EntityManager can only be created on the server.</p>"},{"location":"api/#entitymanagernew","title":"EntityManager.new","text":"<pre><code>EntityManager.new() --&gt; [EntityManager]\n</code></pre> <p>Creates a new EntityManager instance.</p> <pre><code>local entityStats = ModifierManager.EntityManager.new()\n</code></pre>"},{"location":"api/#entitymanagersetbase","title":"EntityManager:SetBase","text":"<pre><code>EntityManager:SetBase(entity, statPath, baseValue)\n-- entity      [string] -- Unique entity identifier\n-- statPath    [string] -- Stat path in \"Category.StatName\" format\n-- baseValue   [number] -- Base value for the stat\n</code></pre> <p>Sets the base value for a stat. Creates the stat if it doesn't exist.</p> <pre><code>entityStats:SetBase(\"enemy_1\", \"Combat.Health\", 100)\nentityStats:SetBase(\"enemy_1\", \"Combat.Damage\", 10)\n</code></pre>"},{"location":"api/#entitymanagersetclamps","title":"EntityManager:SetClamps","text":"<pre><code>EntityManager:SetClamps(entity, statPath, minValue?, maxValue?)\n-- entity      [string]  -- Entity identifier\n-- statPath    [string]  -- Stat path\n-- minValue    [number?] -- Minimum allowed value (nil for no minimum)\n-- maxValue    [number?] -- Maximum allowed value (nil for no maximum)\n</code></pre> <p>Sets min/max bounds for the final calculated value. Stat must exist first.</p> <pre><code>entityStats:SetClamps(\"enemy_1\", \"Combat.Health\", 0, 1000)\n</code></pre>"},{"location":"api/#entitymanagersetdecimalplaces","title":"EntityManager:SetDecimalPlaces","text":"<pre><code>EntityManager:SetDecimalPlaces(entity, statPath, decimalPlaces?)\n-- entity         [string]  -- Entity identifier\n-- statPath       [string]  -- Stat path\n-- decimalPlaces  [number?] -- Number of decimal places (nil for no rounding)\n</code></pre> <p>Sets decimal rounding for the final calculated value.</p> <pre><code>entityStats:SetDecimalPlaces(\"enemy_1\", \"Combat.CritChance\", 2)\n</code></pre>"},{"location":"api/#entitymanageraddmodifier","title":"EntityManager:AddModifier","text":"<pre><code>EntityManager:AddModifier(config) --&gt; [string]\n-- config   [EntityModifierConfig] -- Modifier configuration\n-- Returns the modifier's unique ID\n</code></pre> <p>Adds a modifier to a stat. Returns the modifier ID for later removal.</p> <pre><code>local modifierId = entityStats:AddModifier({\n    entity = \"enemy_1\",\n    path = \"Combat.Health\",\n    value = 50,\n    type = \"Additive\",\n    source = \"HealthPotion\",\n    duration = 30,\n    tags = { \"buff\", \"potion\" },\n})\n</code></pre>"},{"location":"api/#entitymodifierconfig","title":"EntityModifierConfig","text":"Field Type Required Description <code>entity</code> <code>string</code> Yes Entity identifier <code>path</code> <code>string</code> Yes Stat path (\"Category.StatName\") <code>value</code> <code>number</code> Yes Modifier value <code>type</code> <code>ModifierType</code> Yes \"Additive\", \"Multiplicative\", or \"Override\" <code>source</code> <code>string</code> Yes Identifier for stacking/removal <code>priority</code> <code>number?</code> No Override priority (default: 100) <code>tags</code> <code>{string}?</code> No Tags for querying/removal <code>duration</code> <code>number?</code> No Seconds until auto-removal <code>stackingRule</code> <code>StackingRule?</code> No \"Stack\", \"Replace\", \"Highest\", \"Refresh\" (nil = accumulate) <code>minValue</code> <code>number?</code> No Clamp modifier value minimum <code>maxValue</code> <code>number?</code> No Clamp modifier value maximum"},{"location":"api/#entitymanageraddmodifiers","title":"EntityManager:AddModifiers","text":"<pre><code>EntityManager:AddModifiers(configs) --&gt; [{string}]\n-- configs   [{EntityModifierConfig}] -- Array of modifier configs\n-- Returns array of modifier IDs\n</code></pre> <p>Batch add multiple modifiers. More efficient than calling AddModifier multiple times.</p> <pre><code>local ids = entityStats:AddModifiers({\n    { entity = \"enemy_1\", path = \"Combat.Health\", value = 20, type = \"Additive\", source = \"Armor\" },\n    { entity = \"enemy_1\", path = \"Combat.Damage\", value = 1.2, type = \"Multiplicative\", source = \"Rage\" },\n})\n</code></pre>"},{"location":"api/#entitymanagerget","title":"EntityManager:Get","text":"<pre><code>EntityManager:Get(entity, statPath) --&gt; [number]\n-- entity      [string] -- Entity identifier\n-- statPath    [string] -- Stat path\n-- Returns the calculated final value\n</code></pre> <p>Gets the calculated stat value with all modifiers applied.</p> <pre><code>local health = entityStats:Get(\"enemy_1\", \"Combat.Health\")\n</code></pre>"},{"location":"api/#entitymanagergetbase","title":"EntityManager:GetBase","text":"<pre><code>EntityManager:GetBase(entity, statPath) --&gt; [number]\n-- Returns the base value (0 if stat doesn't exist)\n</code></pre> <p>Gets the base value without modifiers.</p>"},{"location":"api/#entitymanagergetmodifiers","title":"EntityManager:GetModifiers","text":"<pre><code>EntityManager:GetModifiers(entity, statPath) --&gt; [{Modifier}]\n-- Returns array of all modifiers on the stat\n</code></pre>"},{"location":"api/#entitymanagergetmodifiersbysource","title":"EntityManager:GetModifiersBySource","text":"<pre><code>EntityManager:GetModifiersBySource(entity, statPath, source) --&gt; [{Modifier}]\n-- source   [string] -- Source identifier to filter by\n</code></pre>"},{"location":"api/#entitymanagergetmodifiersbytag","title":"EntityManager:GetModifiersByTag","text":"<pre><code>EntityManager:GetModifiersByTag(entity, statPath, tag) --&gt; [{Modifier}]\n-- tag   [string] -- Tag to filter by\n</code></pre>"},{"location":"api/#entitymanagerremovemodifierbyid","title":"EntityManager:RemoveModifierById","text":"<pre><code>EntityManager:RemoveModifierById(entity, statPath, modifierId) --&gt; [boolean]\n-- modifierId   [string] -- ID returned from AddModifier\n-- Returns true if modifier was found and removed\n</code></pre>"},{"location":"api/#entitymanagerremovebysource","title":"EntityManager:RemoveBySource","text":"<pre><code>EntityManager:RemoveBySource(entity, statPath, source) --&gt; [number]\n-- Returns count of modifiers removed\n</code></pre> <p>Removes all modifiers with the given source from a specific stat.</p>"},{"location":"api/#entitymanagerremovebytag","title":"EntityManager:RemoveByTag","text":"<pre><code>EntityManager:RemoveByTag(entity, statPath, tag) --&gt; [number]\n-- Returns count of modifiers removed\n</code></pre>"},{"location":"api/#entitymanagerremoveallbysource","title":"EntityManager:RemoveAllBySource","text":"<pre><code>EntityManager:RemoveAllBySource(entity, source) --&gt; [number]\n-- Returns count of modifiers removed\n</code></pre> <p>Removes all modifiers with the given source from ALL stats on the entity.</p> <pre><code>-- Remove all weapon bonuses when unequipping\nentityStats:RemoveAllBySource(\"player_1\", \"EquippedWeapon\")\n</code></pre>"},{"location":"api/#entitymanagerremoveallbytag","title":"EntityManager:RemoveAllByTag","text":"<pre><code>EntityManager:RemoveAllByTag(entity, tag) --&gt; [number]\n-- Returns count of modifiers removed\n</code></pre>"},{"location":"api/#entitymanageronchanged","title":"EntityManager:OnChanged","text":"<pre><code>EntityManager:OnChanged(entity, statPath, callback) --&gt; [Connection]\n-- callback   [(newValue: number) -&gt; ()] -- Called when stat value changes\n-- Returns a Connection that can be disconnected\n</code></pre> <p>Subscribe to stat value changes.</p> <pre><code>local connection = entityStats:OnChanged(\"enemy_1\", \"Combat.Health\", function(newHealth)\n    print(\"Health changed to:\", newHealth)\nend)\n\n-- Later: connection:Disconnect()\n</code></pre>"},{"location":"api/#entitymanagerhasstack","title":"EntityManager:HasStack","text":"<pre><code>EntityManager:HasStack(entity, statPath) --&gt; [boolean]\n-- Returns true if the stat exists\n</code></pre>"},{"location":"api/#entitymanagercleanupentity","title":"EntityManager:CleanupEntity","text":"<pre><code>EntityManager:CleanupEntity(entity)\n-- entity   [string] -- Entity to clean up\n</code></pre> <p>Removes all stats, modifiers, and signals for an entity. Call when entity is destroyed.</p>"},{"location":"api/#entitymanagergetallentities","title":"EntityManager:GetAllEntities","text":"<pre><code>EntityManager:GetAllEntities() --&gt; [{string}]\n-- Returns array of all entity identifiers\n</code></pre>"},{"location":"api/#entitymanagergetentitystats","title":"EntityManager:GetEntityStats","text":"<pre><code>EntityManager:GetEntityStats(entity) --&gt; [{string}]\n-- Returns array of all stat paths for the entity\n</code></pre>"},{"location":"api/#entitymanagergetdebuginfo","title":"EntityManager:GetDebugInfo","text":"<pre><code>EntityManager:GetDebugInfo(entity) --&gt; [table]\n-- Returns debug information about the entity's stats\n</code></pre>"},{"location":"api/#entitymanagerdestroy","title":"EntityManager:Destroy","text":"<pre><code>EntityManager:Destroy()\n</code></pre> <p>Cleans up the manager and all resources. Call when done with the manager.</p>"},{"location":"api/#playermanager","title":"PlayerManager","text":"<p>Server-side manager for Player-keyed stats with automatic client synchronization.</p> <p>Warning</p> <p>PlayerManager can only be created on the server.</p>"},{"location":"api/#playermanagernew","title":"PlayerManager.new","text":"<pre><code>PlayerManager.new() --&gt; [PlayerManager]\n</code></pre> <p>Creates a new PlayerManager instance. Automatically cleans up player data on <code>PlayerRemoving</code>.</p> <pre><code>local playerStats = ModifierManager.PlayerManager.new()\n</code></pre>"},{"location":"api/#playermanageronsyncrequired","title":"PlayerManager.onSyncRequired","text":"<pre><code>PlayerManager.onSyncRequired   [(player: Player, statPath: string, syncData: StatSyncData) -&gt; ()]?\n</code></pre> <p>Callback function invoked when stat data needs to sync to a client. Set this to send data via RemoteEvent. If not set, stat changes are not synced to clients.</p> <pre><code>local StatsRemote = Instance.new(\"RemoteEvent\")\nStatsRemote.Parent = ReplicatedStorage\n\nplayerStats.onSyncRequired = function(player, statPath, syncData)\n    StatsRemote:FireClient(player, statPath, syncData)\nend\n</code></pre>"},{"location":"api/#playermanager-methods","title":"PlayerManager Methods","text":"<p>PlayerManager has the same methods as EntityManager, but uses <code>Player</code> instead of <code>string</code>:</p> Method Description <code>SetBase(player, statPath, value)</code> Set base stat value <code>SetClamps(player, statPath, min?, max?)</code> Set value bounds <code>SetDecimalPlaces(player, statPath, places?)</code> Set decimal rounding <code>AddModifier(config)</code> Add modifier (config requires <code>player: Player</code>) <code>AddModifiers(configs)</code> Batch add modifiers <code>Get(player, statPath)</code> Get calculated value <code>GetBase(player, statPath)</code> Get base value <code>GetModifiers(player, statPath)</code> Get all modifiers <code>GetModifiersBySource(player, statPath, source)</code> Filter by source <code>GetModifiersByTag(player, statPath, tag)</code> Filter by tag <code>RemoveModifierById(player, statPath, id)</code> Remove specific modifier <code>RemoveBySource(player, statPath, source)</code> Remove by source <code>RemoveByTag(player, statPath, tag)</code> Remove by tag <code>RemoveAllBySource(player, source)</code> Remove from all stats <code>RemoveAllByTag(player, tag)</code> Remove from all stats <code>OnChanged(player, statPath, callback)</code> Subscribe to changes <code>HasStack(player, statPath)</code> Check if stat exists <code>GetDebugInfo(player)</code> Debug information <code>Destroy()</code> Cleanup manager"},{"location":"api/#playermanagercleanupplayer","title":"PlayerManager:CleanupPlayer","text":"<pre><code>PlayerManager:CleanupPlayer(player)\n-- player   [Player] -- Player to clean up\n</code></pre> <p>Removes all stats for a player. Called automatically on <code>PlayerRemoving</code>.</p>"},{"location":"api/#playermanagergetallstats","title":"PlayerManager:GetAllStats","text":"<pre><code>PlayerManager:GetAllStats(player) --&gt; [{string}]\n-- Returns array of all stat paths for the player\n</code></pre>"},{"location":"api/#playermanagergetallsyncdata","title":"PlayerManager:GetAllSyncData","text":"<pre><code>PlayerManager:GetAllSyncData(player) --&gt; {[string]: StatSyncData}\n-- Returns a dictionary of stat path -&gt; sync data for initial client sync\n</code></pre> <p>Use this when a player joins to send all current stats:</p> <pre><code>local allData = playerStats:GetAllSyncData(player)\nfor statPath, syncData in allData do\n    StatsRemote:FireClient(player, statPath, syncData)\nend\n</code></pre>"},{"location":"api/#clientstatreader","title":"ClientStatReader","text":"<p>Client-side read-only stat reader for synced player data.</p>"},{"location":"api/#clientstatreadernew","title":"ClientStatReader.new","text":"<pre><code>ClientStatReader.new() --&gt; [ClientStatReader]\n</code></pre> <p>Creates a new ClientStatReader instance.</p> <pre><code>local reader = ModifierManager.ClientStatReader.new()\n</code></pre>"},{"location":"api/#clientstatreaderprocesssync","title":"ClientStatReader:ProcessSync","text":"<pre><code>ClientStatReader:ProcessSync(statPath, syncData)\n-- statPath   [string]       -- Stat path\n-- syncData   [StatSyncData] -- Data received from server\n</code></pre> <p>Process sync data received from the server.</p> <pre><code>StatsRemote.OnClientEvent:Connect(function(statPath, syncData)\n    reader:ProcessSync(statPath, syncData)\nend)\n</code></pre>"},{"location":"api/#clientstatreaderprocessbulksync","title":"ClientStatReader:ProcessBulkSync","text":"<pre><code>ClientStatReader:ProcessBulkSync(allSyncData)\n-- allSyncData   [{[string]: StatSyncData}] -- Multiple stats at once\n</code></pre> <p>Process multiple stats in one call.</p>"},{"location":"api/#clientstatreaderget","title":"ClientStatReader:Get","text":"<pre><code>ClientStatReader:Get(statPath) --&gt; [number]\n-- Returns calculated value (0 if stat doesn't exist)\n</code></pre>"},{"location":"api/#clientstatreadergetbase","title":"ClientStatReader:GetBase","text":"<pre><code>ClientStatReader:GetBase(statPath) --&gt; [number]\n</code></pre>"},{"location":"api/#clientstatreadergetmodifiers","title":"ClientStatReader:GetModifiers","text":"<pre><code>ClientStatReader:GetModifiers(statPath) --&gt; [{Modifier}]\n</code></pre>"},{"location":"api/#clientstatreadergetmodifiersbysource","title":"ClientStatReader:GetModifiersBySource","text":"<pre><code>ClientStatReader:GetModifiersBySource(statPath, source) --&gt; [{Modifier}]\n</code></pre>"},{"location":"api/#clientstatreadergetmodifiersbytag","title":"ClientStatReader:GetModifiersByTag","text":"<pre><code>ClientStatReader:GetModifiersByTag(statPath, tag) --&gt; [{Modifier}]\n</code></pre>"},{"location":"api/#clientstatreaderhasstat","title":"ClientStatReader:HasStat","text":"<pre><code>ClientStatReader:HasStat(statPath) --&gt; [boolean]\n</code></pre>"},{"location":"api/#clientstatreadergetallstats","title":"ClientStatReader:GetAllStats","text":"<pre><code>ClientStatReader:GetAllStats() --&gt; [{string}]\n</code></pre>"},{"location":"api/#clientstatreaderonchanged","title":"ClientStatReader:OnChanged","text":"<pre><code>ClientStatReader:OnChanged(statPath, callback) --&gt; [Connection]\n-- callback   [(newValue: number) -&gt; ()] -- Called when stat updates\n</code></pre> <p>Subscribe to stat changes from server syncs.</p> <pre><code>reader:OnChanged(\"Combat.Health\", function(newHealth)\n    HealthBar:SetValue(newHealth)\nend)\n</code></pre>"},{"location":"api/#clientstatreadergetdebuginfo","title":"ClientStatReader:GetDebugInfo","text":"<pre><code>ClientStatReader:GetDebugInfo() --&gt; [table]\n</code></pre>"},{"location":"api/#clientstatreaderdestroy","title":"ClientStatReader:Destroy","text":"<pre><code>ClientStatReader:Destroy()\n</code></pre>"},{"location":"api/#types","title":"Types","text":""},{"location":"api/#modifiertype","title":"ModifierType","text":"<pre><code>type ModifierType = \"Additive\" | \"Multiplicative\" | \"Override\"\n</code></pre> Type Description <code>Additive</code> Added to base value <code>Multiplicative</code> Multiplies the sum of base + additives <code>Override</code> Replaces final value entirely <p>Calculation Order:</p> <ol> <li>Sum all Additive modifiers: <code>base + additive1 + additive2 + ...</code></li> <li>Multiply by all Multiplicative modifiers: <code>sum * mult1 * mult2 * ...</code></li> <li>If Override exists, use highest priority Override instead</li> <li>Apply clamps and decimal rounding</li> </ol>"},{"location":"api/#stackingrule","title":"StackingRule","text":"<pre><code>type StackingRule = \"Stack\" | \"Replace\" | \"Highest\" | \"Refresh\"\n</code></pre> Rule Behavior <code>Stack</code> All modifiers accumulate <code>Replace</code> New modifier removes existing from same source <code>Highest</code> Only keeps highest value from same source <code>Refresh</code> Updates value and resets duration of existing <p>Note</p> <p>When <code>stackingRule</code> is not provided (<code>nil</code>), modifiers accumulate without any stacking logic \u2014 the same behavior as <code>\"Stack\"</code>, but without checking for existing modifiers from the same source.</p>"},{"location":"api/#modifier","title":"Modifier","text":"<pre><code>type Modifier = {\n    id: string,\n    value: number,\n    modifierType: ModifierType,\n    source: string,\n    priority: number,\n    tags: { string },\n    stackingRule: StackingRule?,\n    expireTime: number?,\n    minValue: number?,\n    maxValue: number?,\n}\n</code></pre>"},{"location":"api/#statsyncdata","title":"StatSyncData","text":"<pre><code>type StatSyncData = {\n    baseValue: number,\n    modifiers: { Modifier },\n    minClamp: number?,\n    maxClamp: number?,\n    decimalPlaces: number?,\n}\n</code></pre>"},{"location":"api/#connection","title":"Connection","text":"<pre><code>type Connection = {\n    Disconnect: (self: Connection) -&gt; (),\n    Connected: boolean,\n}\n</code></pre>"},{"location":"best-practices/","title":"Best Practices","text":"<p>This page shows recommended patterns for structuring a project with ModifierManager. The examples use a movement system, but the same approach applies to any stat-driven gameplay.</p>"},{"location":"best-practices/#data-driven-stat-definitions","title":"Data-Driven Stat Definitions","text":"<p>Instead of hardcoding stat values across scripts, define them once in a shared config.</p>"},{"location":"best-practices/#gamedefaults","title":"GameDefaults","text":"<p>Store your base values in one place:</p> <pre><code>-- ReplicatedStorage/Config/GameDefaults.luau\nlocal GameDefaults = {\n    Movement = {\n        WalkSpeed = 12,\n        SprintSpeed = 18,\n        JumpPower = 50,\n        JumpCooldown = 1,\n    },\n}\n\nreturn GameDefaults\n</code></pre>"},{"location":"best-practices/#modifierpaths","title":"ModifierPaths","text":"<p>Use path constants to avoid string typos:</p> <pre><code>-- ReplicatedStorage/Config/ModifierPaths.luau\nlocal ModifierPaths = {}\n\nModifierPaths.Movement = {\n    WalkSpeed = \"Movement.WalkSpeed\",\n    SprintSpeed = \"Movement.SprintSpeed\",\n    JumpPower = \"Movement.JumpPower\",\n    JumpCooldown = \"Movement.JumpCooldown\",\n}\n\nreturn ModifierPaths\n</code></pre>"},{"location":"best-practices/#statdefinitions","title":"StatDefinitions","text":"<p>Combine defaults, clamps, and decimal precision into typed definitions that the server can loop over:</p> <pre><code>-- ReplicatedStorage/Config/StatDefinitions.luau\nlocal GameDefaults = require(script.Parent.GameDefaults)\nlocal ModifierPaths = require(script.Parent.ModifierPaths)\n\nexport type StatDefinition = {\n    base: number,\n    clamps: { number }?,\n    decimals: number?,\n}\n\nlocal StatDefinitions: { [string]: StatDefinition } = {\n    [ModifierPaths.Movement.WalkSpeed] = {\n        base = GameDefaults.Movement.WalkSpeed,\n        clamps = { 0, 100 },\n        decimals = 1,\n    },\n    [ModifierPaths.Movement.SprintSpeed] = {\n        base = GameDefaults.Movement.SprintSpeed,\n        clamps = { 0, 100 },\n        decimals = 1,\n    },\n    [ModifierPaths.Movement.JumpPower] = {\n        base = GameDefaults.Movement.JumpPower,\n        clamps = { 0, 200 },\n        decimals = 1,\n    },\n    [ModifierPaths.Movement.JumpCooldown] = {\n        base = GameDefaults.Movement.JumpCooldown,\n        clamps = { 0, 10 },\n        decimals = 2,\n    },\n}\n\ntable.freeze(StatDefinitions)\nreturn StatDefinitions\n</code></pre>"},{"location":"best-practices/#config-entry-point","title":"Config Entry Point","text":"<p>Re-export everything from a single module:</p> <pre><code>-- ReplicatedStorage/Config/init.luau\nlocal GameDefaults = require(script.GameDefaults)\nlocal ModifierPaths = require(script.ModifierPaths)\nlocal StatDefinitions = require(script.StatDefinitions)\n\nreturn {\n    GameDefaults = GameDefaults,\n    ModifierPaths = ModifierPaths,\n    StatDefinitions = StatDefinitions,\n}\n</code></pre> <p>Adding a new stat means adding it to <code>GameDefaults</code>, <code>ModifierPaths</code>, and <code>StatDefinitions</code> \u2014 the server and client pick it up automatically.</p>"},{"location":"best-practices/#server-setup","title":"Server Setup","text":"<p>Loop over stat definitions to initialize stats. Use a RemoteEvent for live sync and a RemoteFunction for initial bulk sync:</p> <pre><code>-- ServerScriptService/PlayerStatSetup.server.luau\nlocal Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal ModifierManager = require(ReplicatedStorage.ModifierManager)\nlocal Config = require(ReplicatedStorage.Config)\n\nlocal statSyncEvent = ReplicatedStorage.Remotes.Events.StatSync\nlocal getStatSyncDataFunction = ReplicatedStorage.Remotes.Functions.GetStatSyncData\n\nlocal PlayerStatSetup = {}\n\nlocal playerManager = ModifierManager.PlayerManager.new()\n\nfunction PlayerStatSetup.GetManager()\n    return playerManager\nend\n\nplayerManager.onSyncRequired = function(player: Player, statPath: string, syncData: any)\n    if not player.Parent then\n        return\n    end\n    statSyncEvent:FireClient(player, statPath, syncData)\nend\n\ngetStatSyncDataFunction.OnServerInvoke = function(player: Player)\n    return playerManager:GetAllSyncData(player)\nend\n\nlocal function onPlayerAdded(player: Player)\n    for statPath, definition in Config.StatDefinitions do\n        playerManager:SetBase(player, statPath, definition.base)\n\n        if definition.clamps then\n            playerManager:SetClamps(player, statPath, definition.clamps[1], definition.clamps[2])\n        end\n\n        if definition.decimals then\n            playerManager:SetDecimalPlaces(player, statPath, definition.decimals)\n        end\n    end\nend\n\nPlayers.PlayerAdded:Connect(onPlayerAdded)\nfor _, player in Players:GetPlayers() do\n    task.spawn(onPlayerAdded, player)\nend\n\nreturn PlayerStatSetup\n</code></pre> <p>Other server scripts can require this module and call <code>PlayerStatSetup.GetManager()</code> to add modifiers.</p>"},{"location":"best-practices/#client-setup","title":"Client Setup","text":"<p>The client creates a reader, connects to live sync, and fetches initial data on load:</p> <pre><code>-- StarterPlayerScripts/StatClient.luau\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal ModifierManager = require(ReplicatedStorage.ModifierManager)\n\nlocal statSyncEvent = ReplicatedStorage.Remotes.Events.StatSync\nlocal getStatSyncDataFunction = ReplicatedStorage.Remotes.Functions.GetStatSyncData\n\nlocal StatClient = {}\n\nlocal reader = ModifierManager.ClientStatReader.new()\n\nfunction StatClient.GetReader()\n    return reader\nend\n\nstatSyncEvent.OnClientEvent:Connect(function(statPath: string, syncData: any)\n    reader:ProcessSync(statPath, syncData)\nend)\n\nlocal initialData = getStatSyncDataFunction:InvokeServer()\nif initialData then\n    reader:ProcessBulkSync(initialData)\nend\n\nreturn StatClient\n</code></pre> <p>Other client scripts require <code>StatClient</code> and call <code>StatClient.GetReader()</code> to read stats and subscribe to changes.</p>"},{"location":"best-practices/#driving-gameplay-from-stats","title":"Driving Gameplay From Stats","text":"<p>This is where ModifierManager's value shows. The movement controller below reads stats from the reader and reacts to changes in real time. Sprint speed, walk speed, jump power, and jump cooldown are all driven by modifiers \u2014 any buff or debuff applied on the server automatically updates the client.</p> <pre><code>-- StarterPlayerScripts/MovementController.client.luau\nlocal Players = game:GetService(\"Players\")\nlocal UserInputService = game:GetService(\"UserInputService\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal StatClient = require(script.Parent.StatClient)\nlocal Config = require(ReplicatedStorage.Config)\n\nlocal ModifierPaths = Config.ModifierPaths\nlocal reader = StatClient.GetReader()\nlocal localPlayer = Players.LocalPlayer\n\nlocal SPRINT_KEY = Enum.KeyCode.LeftShift\n\nlocal isSprinting = false\nlocal jumpCooldownActive = false\n\nlocal function getHumanoid(): Humanoid?\n    local character = localPlayer.Character\n    if not character then\n        return nil\n    end\n    return character:FindFirstChildOfClass(\"Humanoid\")\nend\n\nlocal function applyWalkSpeed()\n    local humanoid = getHumanoid()\n    if not humanoid then\n        return\n    end\n\n    if isSprinting then\n        humanoid.WalkSpeed = reader:Get(ModifierPaths.Movement.SprintSpeed)\n    else\n        humanoid.WalkSpeed = reader:Get(ModifierPaths.Movement.WalkSpeed)\n    end\nend\n\nlocal function applyJumpPower()\n    local humanoid = getHumanoid()\n    if not humanoid then\n        return\n    end\n\n    humanoid.UseJumpPower = true\n    humanoid.JumpPower = reader:Get(ModifierPaths.Movement.JumpPower)\nend\n\nlocal function onJumped()\n    if jumpCooldownActive then\n        return\n    end\n\n    local humanoid = getHumanoid()\n    if not humanoid then\n        return\n    end\n\n    jumpCooldownActive = true\n    humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)\n\n    local jumpCooldown = reader:Get(ModifierPaths.Movement.JumpCooldown)\n\n    task.delay(jumpCooldown, function()\n        jumpCooldownActive = false\n        local currentHumanoid = getHumanoid()\n        if not currentHumanoid then\n            return\n        end\n        currentHumanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)\n    end)\nend\n\nlocal function onCharacterAdded(character: Model)\n    isSprinting = false\n    jumpCooldownActive = false\n\n    local humanoid = character:WaitForChild(\"Humanoid\") :: Humanoid\n    applyWalkSpeed()\n    applyJumpPower()\n\n    humanoid.StateChanged:Connect(function(_oldState, newState)\n        if newState == Enum.HumanoidStateType.Jumping then\n            onJumped()\n        end\n    end)\nend\n\n-- React to stat changes from modifiers in real time\nreader:OnChanged(ModifierPaths.Movement.WalkSpeed, function()\n    applyWalkSpeed()\nend)\n\nreader:OnChanged(ModifierPaths.Movement.SprintSpeed, function()\n    applyWalkSpeed()\nend)\n\nreader:OnChanged(ModifierPaths.Movement.JumpPower, function()\n    applyJumpPower()\nend)\n\n-- Sprint input\nUserInputService.InputBegan:Connect(function(input: InputObject, gameProcessed: boolean)\n    if gameProcessed then\n        return\n    end\n    if input.KeyCode == SPRINT_KEY then\n        isSprinting = true\n        applyWalkSpeed()\n    end\nend)\n\nUserInputService.InputEnded:Connect(function(input: InputObject, _gameProcessed: boolean)\n    if input.KeyCode == SPRINT_KEY then\n        isSprinting = false\n        applyWalkSpeed()\n    end\nend)\n\nlocalPlayer.CharacterAdded:Connect(onCharacterAdded)\nif localPlayer.Character then\n    task.spawn(onCharacterAdded, localPlayer.Character)\nend\n</code></pre> <p>The key pattern: <code>OnChanged</code> listeners call functions that read from the reader and apply to the Humanoid. When any modifier changes a stat on the server, the client reacts automatically.</p>"},{"location":"best-practices/#security","title":"Security","text":"<p>All modifiers live on the server. The client only has a <code>ClientStatReader</code> which is read-only \u2014 there is no API for clients to create or modify modifiers. An exploiter can read stat values but cannot give themselves buffs or modify the stat pipeline.</p>"},{"location":"best-practices/#summary","title":"Summary","text":"Pattern Why Shared <code>Config</code> module Single source of truth for stat paths and defaults <code>ModifierPaths</code> constants No magic strings, autocomplete-friendly <code>StatDefinitions</code> with types Data-driven setup, easy to add new stats RemoteFunction for initial sync Client gets all stats immediately on load RemoteEvent for live sync Changes push to client as they happen <code>OnChanged</code> driving gameplay Reactive \u2014 no polling, no manual refresh"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to ModifierManager will be documented in this file.</p>"},{"location":"changelog/#100","title":"1.0.0","text":"<p>Initial release.</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>EntityManager - Server-side stat management for string-keyed entities (NPCs, objects)</li> <li>PlayerManager - Server-side stat management for Player-keyed stats with automatic client synchronization</li> <li>ClientStatReader - Client-side read-only stat reader for synced data</li> <li>Modifier types - Additive, Multiplicative, and Override</li> <li>Stacking rules - Stack, Replace, Highest, Refresh</li> <li>Automatic expiration - Time-based modifier removal with efficient scheduling</li> <li>Change signals - Subscribe to stat value changes via <code>OnChanged</code></li> <li>Tag system - Organize and query modifiers by tags</li> <li>Batch operations - <code>AddModifiers</code> for adding multiple modifiers efficiently</li> <li>Removal methods - Remove by ID, source, or tag (per-stat and cross-stat)</li> <li>Stat configuration - Clamps (<code>SetClamps</code>) and decimal rounding (<code>SetDecimalPlaces</code>)</li> <li>Debug info - <code>GetDebugInfo</code> for inspecting stat state</li> <li>Wally package - Published as <code>estrogenie/modifier-manager</code></li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This guide walks through setting up ModifierManager in a Roblox game.</p>"},{"location":"tutorial/#getting-modifiermanager","title":"Getting ModifierManager","text":""},{"location":"tutorial/#from-github","title":"From GitHub","text":"<p>Download the <code>ModifierManager</code> folder from the repository and place it in <code>ReplicatedStorage</code>.</p>"},{"location":"tutorial/#file-structure","title":"File Structure","text":"<pre><code>ReplicatedStorage/\n\u2514\u2500\u2500 ModifierManager/\n    \u251c\u2500\u2500 init.luau\n    \u251c\u2500\u2500 Types.luau\n    \u251c\u2500\u2500 Calculator.luau\n    \u251c\u2500\u2500 BaseModifierManager.luau\n    \u251c\u2500\u2500 EntityManager.luau\n    \u251c\u2500\u2500 PlayerManager.luau\n    \u251c\u2500\u2500 ClientStatReader.luau\n    \u2514\u2500\u2500 Packages/\n        \u251c\u2500\u2500 Signal.luau\n        \u2514\u2500\u2500 Trove.luau\n</code></pre>"},{"location":"tutorial/#basic-usage","title":"Basic Usage","text":"<p>ModifierManager runs on the server. The example below shows a basic player stat setup with client sync.</p>"},{"location":"tutorial/#server-script","title":"Server Script","text":"<pre><code>-- ServerScriptService/PlayerStats.server.luau\nlocal Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal ModifierManager = require(ReplicatedStorage.ModifierManager)\n\n-- Create manager\nlocal playerStats = ModifierManager.PlayerManager.new()\n\n-- Remotes for sync\nlocal statSyncEvent = ReplicatedStorage.Remotes.Events.StatSync\nlocal getStatSyncDataFunction = ReplicatedStorage.Remotes.Functions.GetStatSyncData\n\n-- Live sync: fires whenever a stat changes\nplayerStats.onSyncRequired = function(player, statPath, syncData)\n    if not player.Parent then\n        return\n    end\n    statSyncEvent:FireClient(player, statPath, syncData)\nend\n\n-- Initial sync: client requests all stats on load\ngetStatSyncDataFunction.OnServerInvoke = function(player: Player)\n    return playerStats:GetAllSyncData(player)\nend\n\n-- Initialize player stats\nlocal function setupPlayer(player: Player)\n    playerStats:SetBase(player, \"Combat.Health\", 100)\n    playerStats:SetBase(player, \"Combat.MaxHealth\", 100)\n    playerStats:SetBase(player, \"Combat.Damage\", 10)\n    playerStats:SetBase(player, \"Movement.Speed\", 16)\n\n    playerStats:SetClamps(player, \"Combat.Health\", 0, nil) -- Min 0, no max\n    playerStats:SetClamps(player, \"Movement.Speed\", 0, 50) -- 0 to 50\nend\n\nPlayers.PlayerAdded:Connect(setupPlayer)\nfor _, player in Players:GetPlayers() do\n    task.spawn(setupPlayer, player)\nend\n</code></pre>"},{"location":"tutorial/#client-script","title":"Client Script","text":"<pre><code>-- StarterPlayerScripts/StatsClient.client.luau\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal ModifierManager = require(ReplicatedStorage.ModifierManager)\n\nlocal reader = ModifierManager.ClientStatReader.new()\nlocal statSyncEvent = ReplicatedStorage.Remotes.Events.StatSync\nlocal getStatSyncDataFunction = ReplicatedStorage.Remotes.Functions.GetStatSyncData\n\n-- Receive live syncs from server\nstatSyncEvent.OnClientEvent:Connect(function(statPath, syncData)\n    reader:ProcessSync(statPath, syncData)\nend)\n\n-- Fetch all current stats on load\nlocal initialData = getStatSyncDataFunction:InvokeServer()\nif initialData then\n    reader:ProcessBulkSync(initialData)\nend\n\n-- React to changes\nreader:OnChanged(\"Combat.Health\", function(newHealth)\n    print(\"Health:\", newHealth)\nend)\n\n-- Read stats anytime\nprint(\"Current speed:\", reader:Get(\"Movement.Speed\"))\n</code></pre>"},{"location":"tutorial/#adding-modifiers","title":"Adding Modifiers","text":"<p>Modifiers change stat values. They can be temporary or permanent.</p>"},{"location":"tutorial/#temporary-buff","title":"Temporary Buff","text":"<pre><code>-- Speed boost that lasts 10 seconds\nplayerStats:AddModifier({\n    player = player,\n    path = \"Movement.Speed\",\n    value = 1.5,\n    type = \"Multiplicative\", -- 50% faster\n    source = \"SpeedBoost\",\n    duration = 10,\n})\n</code></pre>"},{"location":"tutorial/#permanent-equipment-bonus","title":"Permanent Equipment Bonus","text":"<pre><code>-- Weapon damage bonus (no duration = permanent)\nplayerStats:AddModifier({\n    player = player,\n    path = \"Combat.Damage\",\n    value = 25,\n    type = \"Additive\",\n    source = \"EquippedSword\",\n    tags = { \"equipment\", \"weapon\" },\n})\n</code></pre>"},{"location":"tutorial/#debuff-with-override","title":"Debuff with Override","text":"<pre><code>-- Stun: force speed to 0\nplayerStats:AddModifier({\n    player = player,\n    path = \"Movement.Speed\",\n    value = 0,\n    type = \"Override\",\n    source = \"Stun\",\n    duration = 2,\n    priority = 200, -- Higher priority overrides win\n})\n</code></pre>"},{"location":"tutorial/#stacking-rules","title":"Stacking Rules","text":"<p>Control how modifiers from the same source interact.</p>"},{"location":"tutorial/#stack-default","title":"Stack (Default)","text":"<p>Multiple modifiers accumulate:</p> <pre><code>-- Each hit adds more damage\nplayerStats:AddModifier({\n    player = player,\n    path = \"Combat.Damage\",\n    value = 5,\n    type = \"Additive\",\n    source = \"RageStack\",\n    stackingRule = \"Stack\",\n})\n-- Call 3 times = +15 damage total\n</code></pre>"},{"location":"tutorial/#replace","title":"Replace","text":"<p>New modifier removes old ones from same source:</p> <pre><code>-- Only one weapon equipped at a time\nplayerStats:AddModifier({\n    player = player,\n    path = \"Combat.Damage\",\n    value = newWeaponDamage,\n    type = \"Additive\",\n    source = \"EquippedWeapon\",\n    stackingRule = \"Replace\",\n})\n</code></pre>"},{"location":"tutorial/#highest","title":"Highest","text":"<p>Only keeps the highest value:</p> <pre><code>-- Only strongest shield matters\nplayerStats:AddModifier({\n    player = player,\n    path = \"Combat.Defense\",\n    value = shieldValue,\n    type = \"Additive\",\n    source = \"Shield\",\n    stackingRule = \"Highest\",\n})\n</code></pre>"},{"location":"tutorial/#refresh","title":"Refresh","text":"<p>Updates existing modifier's value and resets duration:</p> <pre><code>-- Reapplying refreshes the timer\nplayerStats:AddModifier({\n    player = player,\n    path = \"Combat.Damage\",\n    value = 1.2,\n    type = \"Multiplicative\",\n    source = \"Enrage\",\n    stackingRule = \"Refresh\",\n    duration = 5,\n})\n</code></pre>"},{"location":"tutorial/#removing-modifiers","title":"Removing Modifiers","text":""},{"location":"tutorial/#by-id","title":"By ID","text":"<pre><code>local modId = playerStats:AddModifier({ ... })\n\n-- Later\nplayerStats:RemoveModifierById(player, \"Combat.Damage\", modId)\n</code></pre>"},{"location":"tutorial/#by-source","title":"By Source","text":"<pre><code>-- Remove all modifiers from \"EquippedWeapon\" on one stat\nplayerStats:RemoveBySource(player, \"Combat.Damage\", \"EquippedWeapon\")\n\n-- Remove from ALL stats\nplayerStats:RemoveAllBySource(player, \"EquippedWeapon\")\n</code></pre>"},{"location":"tutorial/#by-tag","title":"By Tag","text":"<pre><code>-- Remove all buffs\nplayerStats:RemoveAllByTag(player, \"buff\")\n\n-- Remove all debuffs\nplayerStats:RemoveAllByTag(player, \"debuff\")\n</code></pre>"},{"location":"tutorial/#entitymanager-for-npcs","title":"EntityManager for NPCs","text":"<p>Use EntityManager for non-player entities with string keys:</p> <pre><code>local entityStats = ModifierManager.EntityManager.new()\n\n-- Setup enemy\nentityStats:SetBase(\"goblin_1\", \"Combat.Health\", 50)\nentityStats:SetBase(\"goblin_1\", \"Combat.Damage\", 5)\n\n-- Apply poison\nentityStats:AddModifier({\n    entity = \"goblin_1\",\n    path = \"Combat.Health\",\n    value = -10,\n    type = \"Additive\",\n    source = \"Poison\",\n    duration = 5,\n})\n\n-- Cleanup when enemy dies\nentityStats:CleanupEntity(\"goblin_1\")\n</code></pre>"},{"location":"tutorial/#listening-to-changes","title":"Listening to Changes","text":"<p>React when stats change:</p> <pre><code>-- Server\nplayerStats:OnChanged(player, \"Combat.Health\", function(newHealth)\n    if newHealth &lt;= 0 then\n        -- Player died\n    end\nend)\n\n-- Client\nreader:OnChanged(\"Combat.Health\", function(newHealth)\n    HealthBar.Size = UDim2.new(newHealth / maxHealth, 0, 1, 0)\nend)\n</code></pre>"},{"location":"tutorial/#calculation-example","title":"Calculation Example","text":"<p>Given:</p> <ul> <li>Base: 100</li> <li>Additive modifiers: +20, +10</li> <li>Multiplicative modifiers: 1.2, 1.1</li> </ul> <p>Calculation:</p> <ol> <li>Sum additives: <code>100 + 20 + 10 = 130</code></li> <li>Multiply: <code>130 * 1.2 * 1.1 = 171.6</code></li> </ol> <p>If an Override modifier exists with the highest priority, it replaces the result entirely.</p>"},{"location":"tutorial/#edge-cases","title":"Edge Cases","text":"<p>A few things to keep in mind:</p> <ul> <li>Reading a stat that doesn't exist returns <code>0</code> \u2014 no errors are thrown.</li> <li><code>SetClamps</code> and <code>SetDecimalPlaces</code> require the stat to exist first. Call <code>SetBase</code> before using them, or you'll get an error.</li> <li>Stat paths must be in <code>\"Category.StatName\"</code> format. A path like <code>\"Health\"</code> or <code>\"A.B.C\"</code> will error.</li> <li><code>EntityManager</code> and <code>PlayerManager</code> can only be created on the server. Attempting to call <code>.new()</code> on the client will error.</li> </ul> <pre><code>-- This is safe \u2014 returns 0\nlocal health = entityStats:Get(\"nonexistent\", \"Combat.Health\")\n\n-- This will error \u2014 stat doesn't exist yet\nentityStats:SetClamps(\"enemy_1\", \"Combat.Health\", 0, 100)\n\n-- Do this instead\nentityStats:SetBase(\"enemy_1\", \"Combat.Health\", 50)\nentityStats:SetClamps(\"enemy_1\", \"Combat.Health\", 0, 100)\n</code></pre>"},{"location":"tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>Best Practices - Data-driven config, recommended sync patterns, and a full movement system example</li> <li>API Reference - Complete method documentation and type definitions</li> </ul>"}]}